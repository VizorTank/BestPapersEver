#pragma kernel BitonicSort
#pragma kernel Test

// groupshared uint Array[1024];
RWStructuredBuffer<int> Array;
int ArrayLength;

// Parameter is SV_GroupIndex
[numthreads(1024, 1, 1)]
void BitonicSort(uint3 id : SV_DispatchThreadID)//uint localIdxFlattened : SV_GroupIndex)
{
    // uint index = id.x;
    uint localIdxFlattened = id.x;
    uint numArray = ArrayLength;
    uint numArrayPowerOfTwo = 2 << (firstbithigh(numArray - 1) + 1);

    // uint numArrayPowerOfTwo = 1;
    // while (numArrayPowerOfTwo < numArray)
    //     numArrayPowerOfTwo <<= 1;
    
    AllMemoryBarrierWithGroupSync();

    for( uint nMergeSize = 2; nMergeSize <= numArrayPowerOfTwo; nMergeSize = nMergeSize * 2 )
    {
        for( uint nMergeSubSize = nMergeSize >> 1; nMergeSubSize > 0; nMergeSubSize = nMergeSubSize >> 1 )
        {
            uint tmp_index = localIdxFlattened;
            // index in bracket
            uint index_low = tmp_index & ( nMergeSubSize - 1 );
            // index 
            uint index_high = 2 * ( tmp_index - index_low );
            uint index = index_high + index_low;

            uint nSwapElem = nMergeSubSize == nMergeSize >> 1 ? index_high + ( 2 * nMergeSubSize - 1 ) - index_low : index_high + nMergeSubSize + index_low;
			
            if( nSwapElem < numArray && index < numArray )
            {
                if( Array[ index ] > Array[ nSwapElem ] )
                {
                    uint uTemp = Array[ index ];
                    Array[ index ] = Array[ nSwapElem ];
                    Array[ nSwapElem ] = uTemp;
                }
            }
            AllMemoryBarrierWithGroupSync();
        }
    }
}

RWStructuredBuffer<int> tests;
int testId;

[numthreads(1024, 1, 1)]
void Test(uint3 id : SV_DispatchThreadID)
{
    if (id.x == 0) return;
    if (Array[id.x - 1] > Array[id.x]) tests[testId] = 1;
}