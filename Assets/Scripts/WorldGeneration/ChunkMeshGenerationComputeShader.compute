// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

//RWTexture2D<float4> Result;

// BlockList[X, Y, Z]
// Contains blockID
RWBuffer<int> BlockList;

// BlockTypeIsSolid[BlockID]
// Contains is block solid
RWBuffer<int> BlockTypeIsSolid;

// BlockFaceCheck[X, Y, Z, FaceID]
// Render if true
RWBuffer<int> BlockFaceCheck;

static const int3 FaceChecks[6] = {
    int3(0, 0, -1),
    int3(0, 0, 1),
    int3(0, 1, 0),
    int3(0, -1, 0),
    int3(-1, 0, 0),
    int3(1, 0, 0)
};
int3 ChunkSize;

int index(uint3 id)
{
    return id.z + (id.y + id.x * ChunkSize.y) * ChunkSize.z;
}

bool isVoxelInChunk(int3 position)
{
    if (position.x < 0 || position.x >= ChunkSize.x ||
        position.y < 0 || position.y >= ChunkSize.y ||
        position.z < 0 || position.z >= ChunkSize.z)
        return false;
    return true;
}

bool CheckVoxelIfSolid(int3 position)
{
    if (!isVoxelInChunk(position))
        return false;

    return BlockTypeIsSolid[BlockList[index(position)]];
}

int BlockFaceCheckIndex(uint3 position, int face)
{
    return face + (position.z + (position.y + position.x * ChunkSize.y) * ChunkSize.z) * 6;
}

void SetVoxelData(uint3 position)
{
    for (uint i = 0; i < 6; i++)
    {
        BlockFaceCheck[BlockFaceCheckIndex(position, i)] = !CheckVoxelIfSolid(position + FaceChecks[i]);
    }
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    SetVoxelData(id);
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
